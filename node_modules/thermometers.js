var sys = require('sys');
var events = require('events');
var fs = require('fs');

var Thermometer = module.exports.Thermometer = function(devicePath) {
    var self = this;
    events.EventEmitter.call(this);
    
    self.deviceId = devicePath.match(/[^\/]+$/)[0];
    self.emit('tConnect', {device: self.deviceId});
    
    var read = function() {
        var data = {device: self.deviceId, time: new Date().getTime()};
        
        fs.readFile(devicePath + '/w1_slave', 'utf8', function(err, raw){
            if (err) {
                self.emit('tFail', data);
                setTimeout(read, 1000); // If file read failed, try again in a second.
                return;
            }
            
            var matches = raw.match(/(([a-f\d]{2} ){9}): crc=([a-f\d]{2}) (YES|NO)\r?\n([a-f\d]{2} ){9}t=(-?\d+)/);
            if (!matches) {
                // Something went really wrong. Did the thermometer melt?
                throw new Error("Data did not match expected pattern");
            }
            
            data.id = matches[1].trim();
            data.crc = matches[4] == 'YES';
            data.t = parseInt(matches[6])/1000;

            self.emit(data.crc ? 'tData' : 'tFail', [data]);
            //process.nextTick(read);
            setTimeout(read, 1000)
        });
    };
    
    var failureStreak = 0;
    self.on('tFail', function(){
        if (++failureStreak == 5) {
            // Upon five consecutive failures, assume disconnected.
            self.emit('tDisconnect', {device: self.deviceId});
        }
    });
    self.on('tData', function(){
        if (failureStreak >= 5) {
            self.emit('tConnect', {device: self.deviceId});
        }
        failureStreak = 0;
    });
    
    process.nextTick(read);
};
sys.inherits(Thermometer, events.EventEmitter);

var ThermometerLab = module.exports.ThermometerLab = function(busDevicesPath) {
    var self = this;
    events.EventEmitter.call(this);
    
    var discoveredDevices = {};
    self.getDevices = function() {
        return discoveredDevices;
    };
    
    var poll = function() {
        fs.readdir(busDevicesPath, function(err, items){
            if (!err) {
                items.forEach(function(item){
                    if (!/^28-[\da-f]+$/.test(item)) {
                        return;
                    }
                    
                    if (!!discoveredDevices[item])
                        return;
                    
                    var devicePath = busDevicesPath + item;
                    discoveredDevices[item] = new Thermometer(devicePath);
                    self.emit('connect', discoveredDevices[item]);
                });
            }
            
            setTimeout(poll, 3000); // Poll again in a few seconds.
        });
    };
    process.nextTick(poll);
};
sys.inherits(ThermometerLab, events.EventEmitter);

var ThermometerLogger = module.exports.ThermometerLogger = function(thermoLab, db) {
    this.thermoLab = thermoLab;
    this.db = db;
    
    db.serialize();
    db.run("CREATE TABLE IF NOT EXISTS temperature_log (sensor_id INT, timestamp INT, value REAL)");
    db.run("CREATE TABLE IF NOT EXISTS temperature_sensors (device_id TEXT UNIQUE, nickname TEXT, colour INT)");
    db.run("CREATE TABLE IF NOT EXISTS logging_sessions (start INT, end INT, name TEXT)");

    var logStmt = db.prepare(
        'INSERT INTO temperature_log (sensor_id, timestamp, value)'+
        'SELECT ROWID, ?, ? FROM temperature_sensors WHERE device_id = ?'
    );
    var newSensorStmt = db.prepare(
        'INSERT OR IGNORE INTO temperature_sensors (device_id) VALUES (?)'
    );
    
    thermoLab.on('connect', function(t, data) {
        // Add new temperature sensors to database as they are plugged in
        console.log('New Sensor', t.deviceId);
        newSensorStmt.run(t.deviceId);
        
        t.on('tData', function(data){
            // Log all valid data
            data.forEach(function(entry) {
                console.log('Logging', entry.t, 'Â°C against', entry.device);
                logStmt.run(entry.time, entry.t, entry.device);
            });
        });
    });
};
ThermometerLogger.prototype = {
    startSession: function() {
    },
    stopSession: function() {
    },
    getSensorLog: function(deviceId, durationMs, callback) {
        this.db.all('SELECT s.device_id as device, l.value as t, l.timestamp as time FROM temperature_log l JOIN temperature_sensors s ON s.ROWID = l.sensor_id WHERE l.timestamp > ? AND s.device_id = ?', new Date().getTime() - durationMs, deviceId, function(err, rows){
            callback(rows);
        });
    }
};
